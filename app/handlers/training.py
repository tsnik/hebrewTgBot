# -*- coding: utf-8 -*-

from datetime import datetime, timedelta

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.constants import ParseMode

from config import (
    logger,
    TRAINING_MENU_STATE,
    FLASHCARD_SHOW,
    FLASHCARD_EVAL,
    AWAITING_VERB_ANSWER,
    VERB_TRAINER_NEXT_ACTION,
    CB_TRAIN_MENU,
    CB_TRAIN_HE_RU,
    CB_TRAIN_RU_HE,
    CB_VERB_TRAINER_START,
    CB_SHOW_ANSWER,
    CB_EVAL_CORRECT,
    CB_EVAL_INCORRECT,
    CB_END_TRAINING,
    CB_SETTINGS_MENU,
    VERB_TRAINER_RETRY_ATTEMPTS,
    PERSON_MAP,
    TENSE_MAP,
)
from dal.unit_of_work import UnitOfWork
from utils import normalize_hebrew, set_request_id
from metrics import increment_callbacks_counter, increment_messages_counter

# --- –í—Ö–æ–¥ –≤ –º–µ–Ω—é —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫ ---


@increment_callbacks_counter
@set_request_id
async def training_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ —Ä–µ–∂–∏–º–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏."""
    query = update.callback_query

    keyboard = [
        [
            InlineKeyboardButton(
                "üáÆüá± ‚Üí üá∑üá∫ (–ò–≤—Ä–∏—Ç ‚Üí –†—É—Å—Å–∫–∏–π)", callback_data=CB_TRAIN_HE_RU
            )
        ],
        [
            InlineKeyboardButton(
                "üá∑üá∫ ‚Üí üáÆüá± (–†—É—Å—Å–∫–∏–π ‚Üí –ò–≤—Ä–∏—Ç)", callback_data=CB_TRAIN_RU_HE
            )
        ],
        [
            InlineKeyboardButton(
                "üî• –ì–ª–∞–≥–æ–ª—ã (–°–ø—Ä—è–∂–µ–Ω–∏–µ)", callback_data=CB_VERB_TRAINER_START
            )
        ],
        [InlineKeyboardButton("‚¨ÖÔ∏è –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="main_menu")],
    ]

    if query:
        await query.answer()
        await query.edit_message_text(
            text="–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏:",
            reply_markup=InlineKeyboardMarkup(keyboard),
        )
    else:
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="–í—ã–±–µ—Ä–∏—Ç–µ —Ä–µ–∂–∏–º —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏:",
            reply_markup=InlineKeyboardMarkup(keyboard),
        )

    return TRAINING_MENU_STATE


# --- –õ–æ–≥–∏–∫–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ "–ö–∞—Ä—Ç–æ—á–∫–∏" (Flashcards) ---


@increment_callbacks_counter
@set_request_id
async def start_flashcard_training(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> int:
    """–ù–∞—á–∏–Ω–∞–µ—Ç —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É —Å –∫–∞—Ä—Ç–æ—á–∫–∞–º–∏."""
    query = update.callback_query
    await query.answer()
    context.user_data["training_mode"] = query.data

    with UnitOfWork() as uow:
        words = uow.user_dictionary.get_user_words_for_training(query.from_user.id, 10)

    if not words:
        await query.edit_message_text(
            "–í —Å–ª–æ–≤–∞—Ä–µ –Ω–µ—Ç —Å–ª–æ–≤ (—Å—É—â–µ—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã—Ö/–ø—Ä–∏–ª–∞–≥–∞—Ç–µ–ª—å–Ω—ã—Ö) –¥–ª—è —ç—Ç–æ–π —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏.",
            reply_markup=InlineKeyboardMarkup(
                [[InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=CB_TRAIN_MENU)]]
            ),
        )
        return TRAINING_MENU_STATE

    context.user_data.update({"words": words, "idx": 0, "correct": 0})
    return await show_next_card(update, context)


async def show_next_card(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ª–µ–¥—É—é—â—É—é –∫–∞—Ä—Ç–æ—á–∫—É –≤ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ."""
    query = update.callback_query
    if query:
        await query.answer()

    idx = context.user_data.get("idx", 0)
    words = context.user_data.get("words", [])

    if idx >= len(words):
        await query.edit_message_text(
            f"–¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!\n\n–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {context.user_data.get('correct', 0)} / {len(words)}",
            reply_markup=InlineKeyboardMarkup(
                [
                    [
                        InlineKeyboardButton(
                            "üí™ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å",
                            callback_data=context.user_data["training_mode"],
                        )
                    ],
                    [
                        InlineKeyboardButton(
                            "‚¨ÖÔ∏è –í –º–µ–Ω—é —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫", callback_data=CB_TRAIN_MENU
                        )
                    ],
                ]
            ),
        )
        context.user_data.clear()
        return TRAINING_MENU_STATE

    word = words[idx]
    question = (
        word.hebrew
        if context.user_data["training_mode"] == CB_TRAIN_HE_RU
        else word.translations[0].translation_text
    )
    keyboard = [
        [InlineKeyboardButton("üí° –ü–æ–∫–∞–∑–∞—Ç—å –æ—Ç–≤–µ—Ç", callback_data=CB_SHOW_ANSWER)],
        [InlineKeyboardButton("‚ùå –ó–∞–∫–æ–Ω—á–∏—Ç—å", callback_data=CB_END_TRAINING)],
    ]

    message_text = f"–°–ª–æ–≤–æ {idx + 1}/{len(words)}:\n\n*{question}*"
    reply_markup = InlineKeyboardMarkup(keyboard)

    if query:
        await query.edit_message_text(
            text=message_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN
        )

    return FLASHCARD_SHOW


@increment_callbacks_counter
@set_request_id
async def show_answer(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –æ—Ç–≤–µ—Ç –Ω–∞ –∫–∞—Ä—Ç–æ—á–∫–µ."""
    query = update.callback_query
    await query.answer()

    word = context.user_data["words"][context.user_data["idx"]]
    answer_text = f"*{word.hebrew}* [{word.transcription}]\n\n–ü–µ—Ä–µ–≤–æ–¥: *{word.translations[0].translation_text}*"
    keyboard = [
        [InlineKeyboardButton("‚úÖ –ó–Ω–∞—é", callback_data=CB_EVAL_CORRECT)],
        [InlineKeyboardButton("‚ùå –ù–µ –∑–Ω–∞—é", callback_data=CB_EVAL_INCORRECT)],
    ]
    await query.edit_message_text(
        answer_text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode=ParseMode.MARKDOWN,
    )
    return FLASHCARD_EVAL


@increment_callbacks_counter
@set_request_id
async def handle_self_evaluation(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> int:
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–∞–º–æ–æ—Ü–µ–Ω–∫—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–∑–Ω–∞—é/–Ω–µ –∑–Ω–∞—é)."""
    query = update.callback_query
    word = context.user_data["words"][context.user_data["idx"]]

    with UnitOfWork() as uow:
        srs_level = uow.user_dictionary.get_srs_level(query.from_user.id, word.word_id)
        srs_level = srs_level if srs_level is not None else 0

        if query.data == CB_EVAL_CORRECT:
            context.user_data["correct"] += 1
            srs_level += 1
        else:
            srs_level = 0

        srs_intervals = [0, 1, 3, 7, 14, 30, 90]
        days_to_add = srs_intervals[min(srs_level, len(srs_intervals) - 1)]
        next_review_date = datetime.now() + timedelta(days=days_to_add)

        uow.user_dictionary.update_srs_level(
            srs_level, next_review_date, query.from_user.id, word.word_id
        )
        uow.commit()

    context.user_data["idx"] += 1
    return await show_next_card(update, context)


# --- –õ–æ–≥–∏–∫–∞ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ –≥–ª–∞–≥–æ–ª–æ–≤ ---


@increment_callbacks_counter
@set_request_id
async def start_verb_trainer(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """–ù–∞—á–∏–Ω–∞–µ—Ç —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É –≥–ª–∞–≥–æ–ª–æ–≤ —Å —É—á–µ—Ç–æ–º –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id

    with UnitOfWork() as uow:
        user_settings = uow.user_settings.get_user_settings(user_id)
        if not user_settings.tense_settings:
            uow.user_settings.initialize_tense_settings(user_id)
            uow.commit()
            user_settings = uow.user_settings.get_user_settings(user_id)

        active_tenses = user_settings.get_active_tenses()

        if not active_tenses:
            keyboard = [
                [InlineKeyboardButton("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data=CB_SETTINGS_MENU)],
                [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=CB_TRAIN_MENU)],
            ]
            await query.edit_message_text(
                "–ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É, –≤—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω–æ –≤—Ä–µ–º—è –≤ —Ä–∞–∑–¥–µ–ª–µ '–ù–∞—Å—Ç—Ä–æ–π–∫–∏'.",
                reply_markup=InlineKeyboardMarkup(keyboard),
            )
            return TRAINING_MENU_STATE

        verb, conjugation = None, None
        for i in range(VERB_TRAINER_RETRY_ATTEMPTS):
            verb_candidate = uow.words.get_random_verb_for_training(user_id)
            if not verb_candidate:
                await query.edit_message_text(
                    "–í –≤–∞—à–µ–º —Å–ª–æ–≤–∞—Ä–µ –Ω–µ—Ç –≥–ª–∞–≥–æ–ª–æ–≤ –¥–ª—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏.",
                    reply_markup=InlineKeyboardMarkup(
                        [[InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=CB_TRAIN_MENU)]]
                    ),
                )
                return TRAINING_MENU_STATE

            conjugation_candidate = uow.words.get_random_conjugation_for_word(
                verb_candidate.word_id, active_tenses
            )
            if conjugation_candidate:
                verb, conjugation = verb_candidate, conjugation_candidate
                break
            else:
                logger.warning(
                    f"–ù–µ –Ω–∞–π–¥–µ–Ω–æ —Å–ø—Ä—è–∂–µ–Ω–∏–π –≤ –∞–∫—Ç–∏–≤–Ω—ã—Ö –≤—Ä–µ–º–µ–Ω–∞—Ö –¥–ª—è –≥–ª–∞–≥–æ–ª–∞ {verb_candidate.hebrew}. –ü–æ–ø—ã—Ç–∫–∞ {i + 1}"
                )
    if not verb or not conjugation:
        logger.warning(
            f"Could not find a suitable verb for training for user after {VERB_TRAINER_RETRY_ATTEMPTS} retries."
        )
        await query.edit_message_text(
            "–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø–æ–¥—Ö–æ–¥—è—â–∏–π –≥–ª–∞–≥–æ–ª –¥–ª—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏. –í–æ–∑–º–æ–∂–Ω–æ, –¥–ª—è –≥–ª–∞–≥–æ–ª–æ–≤ –≤ –≤–∞—à–µ–º —Å–ª–æ–≤–∞—Ä–µ –Ω–µ—Ç —Å–ø—Ä—è–∂–µ–Ω–∏–π –≤ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –≤—Ä–µ–º–µ–Ω–∞—Ö.",
            reply_markup=InlineKeyboardMarkup(
                [[InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=CB_TRAIN_MENU)]]
            ),
        )
        return TRAINING_MENU_STATE

    context.user_data["answer"] = conjugation

    person_display = PERSON_MAP.get(conjugation.person.value, conjugation.person.value)
    tense_display = TENSE_MAP.get(
        conjugation.tense.value, conjugation.tense.value
    ).capitalize()

    question_text = f"–ì–ª–∞–≥–æ–ª: *{verb.hebrew}*\n\n–ù–∞–ø–∏—à–∏—Ç–µ –µ–≥–æ —Ñ–æ—Ä–º—É –¥–ª—è:\n*{tense_display}, {person_display}*"
    await query.edit_message_text(question_text, parse_mode=ParseMode.MARKDOWN)

    return AWAITING_VERB_ANSWER


@increment_messages_counter
@set_request_id
async def check_verb_answer(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –æ—Ç–≤–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ –≥–ª–∞–≥–æ–ª–æ–≤."""
    correct_answer = context.user_data.get("answer")
    if not correct_answer:
        return await training_menu(update, context)

    user_answer_normalized = normalize_hebrew(update.message.text)
    correct_answer_normalized = normalize_hebrew(correct_answer.hebrew_form)

    is_correct = user_answer_normalized == correct_answer_normalized
    logger.info(
        f"Verb training check. "
        f"User answer: '{user_answer_normalized}', "
        f"Correct answer: '{correct_answer_normalized}', "
        f"Result: {'CORRECT' if is_correct else 'INCORRECT'}"
    )

    if is_correct:
        reply_text = f"‚úÖ –í–µ—Ä–Ω–æ!\n\n*{correct_answer.hebrew_form}* [{correct_answer.transcription}]"
    else:
        reply_text = f"‚ùå –û—à–∏–±–∫–∞.\n\n–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: *{correct_answer.hebrew_form}* [{correct_answer.transcription}]"

    with UnitOfWork() as uow:
        uow.user_dictionary.update_srs_level(
            0,
            datetime.now() + timedelta(days=1),
            update.effective_user.id,
            correct_answer.word_id,
        )
        uow.commit()

    keyboard = [
        [InlineKeyboardButton("üî• –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å", callback_data=CB_VERB_TRAINER_START)],
        [InlineKeyboardButton("‚¨ÖÔ∏è –í –º–µ–Ω—é —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫", callback_data=CB_TRAIN_MENU)],
    ]
    await update.message.reply_text(
        reply_text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode=ParseMode.MARKDOWN,
    )

    return VERB_TRAINER_NEXT_ACTION


# --- –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ ---


@increment_callbacks_counter
@set_request_id
async def end_training(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–≤–µ—Ä—à–∞–µ—Ç –ª—é–±—É—é —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É."""
    query = update.callback_query
    await query.answer()

    keyboard = [
        [
            InlineKeyboardButton(
                "üáÆüá± ‚Üí üá∑üá∫ (–ò–≤—Ä–∏—Ç ‚Üí –†—É—Å—Å–∫–∏–π)", callback_data=CB_TRAIN_HE_RU
            )
        ],
        [
            InlineKeyboardButton(
                "üá∑üá∫ ‚Üí üáÆüá± (–†—É—Å—Å–∫–∏–π ‚Üí –ò–≤—Ä–∏—Ç)", callback_data=CB_TRAIN_RU_HE
            )
        ],
        [
            InlineKeyboardButton(
                "üî• –ì–ª–∞–≥–æ–ª—ã (–°–ø—Ä—è–∂–µ–Ω–∏–µ)", callback_data=CB_VERB_TRAINER_START
            )
        ],
        [InlineKeyboardButton("‚¨ÖÔ∏è –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="main_menu")],
    ]
    await query.edit_message_text(
        text="–¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –ø—Ä–µ—Ä–≤–∞–Ω–∞. –í—ã–±–µ—Ä–∏—Ç–µ –Ω–æ–≤—ã–π —Ä–µ–∂–∏–º:",
        reply_markup=InlineKeyboardMarkup(keyboard),
    )

    return TRAINING_MENU_STATE
